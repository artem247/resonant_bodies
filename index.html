<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Resonant Bodies - Physical Modeling Synthesizer</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                    Roboto, sans-serif;
                background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
                color: #e0e0e0;
                min-height: 100vh;
                overflow-x: hidden;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 20px;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                font-size: 2.5em;
                background: linear-gradient(45deg, #00d4aa, #0099ff);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                text-shadow: 0 0 30px rgba(0, 212, 170, 0.3);
            }

            .main-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin-bottom: 20px;
            }

            @media (max-width: 768px) {
                .main-grid {
                    grid-template-columns: 1fr;
                }
            }

            .panel {
                background: rgba(255, 255, 255, 0.05);
                border-radius: 15px;
                padding: 20px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            .panel h3 {
                color: #00d4aa;
                margin-bottom: 15px;
            }

            .visualization {
                position: relative;
                height: 400px;
                background: radial-gradient(
                    circle at center,
                    rgba(0, 212, 170, 0.05),
                    transparent
                );
                border-radius: 10px;
                overflow: hidden;
            }

            canvas {
                width: 100%;
                height: 100%;
            }

            .controls {
                display: grid;
                gap: 15px;
            }

            .control-group {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .control-group label {
                font-size: 0.9em;
                color: #00d4aa;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            .slider-container {
                display: flex;
                align-items: center;
                gap: 15px;
            }

            input[type="range"] {
                flex: 1;
                height: 6px;
                background: linear-gradient(90deg, #00d4aa 0%, #0099ff 100%);
                border-radius: 3px;
                outline: none;
                -webkit-appearance: none;
            }

            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 20px;
                height: 20px;
                background: radial-gradient(circle, #fff, #00d4aa);
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(0, 212, 170, 0.5);
            }

            input[type="range"]:focus-visible {
                outline: 2px solid #00d4aa;
                outline-offset: 2px;
            }

            .value-display {
                min-width: 50px;
                text-align: right;
                color: #0099ff;
                font-weight: bold;
                font-variant-numeric: tabular-nums;
            }

            .button-grid {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
            }

            button {
                padding: 12px 20px;
                background: linear-gradient(135deg, #00d4aa, #0099ff);
                color: #0a0e27;
                border: none;
                border-radius: 8px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            button:hover:not(:disabled) {
                transform: translateY(-2px);
                box-shadow: 0 5px 20px rgba(0, 212, 170, 0.4);
            }

            button:active:not(:disabled) {
                transform: translateY(0);
            }

            button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            button:focus-visible {
                outline: 2px solid #00d4aa;
                outline-offset: 2px;
            }

            .excitation-buttons {
                display: grid;
                grid-template-columns: repeat(4, 1fr);
                gap: 10px;
                margin-top: 10px;
            }

            .excitation-btn {
                padding: 8px;
                font-size: 0.85em;
                background: linear-gradient(
                    135deg,
                    rgba(0, 212, 170, 0.2),
                    rgba(0, 153, 255, 0.2)
                );
            }

            .material-space {
                position: relative;
                height: 200px;
                background: radial-gradient(
                    ellipse at center,
                    rgba(0, 153, 255, 0.1),
                    transparent
                );
                border-radius: 10px;
                margin-top: 15px;
                cursor: crosshair;
            }

            #materialIndicator {
                position: absolute;
                width: 20px;
                height: 20px;
                background: radial-gradient(circle, #fff, #00d4aa);
                border-radius: 50%;
                box-shadow: 0 0 20px rgba(0, 212, 170, 0.8);
                transform: translate(-50%, -50%);
                pointer-events: none;
            }

            .spectrum-display {
                height: 100px;
                background: linear-gradient(
                    180deg,
                    transparent,
                    rgba(0, 212, 170, 0.05)
                );
                border-radius: 10px;
                position: relative;
                overflow: hidden;
            }

            .topology-selector {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
            }

            .topology-btn {
                padding: 8px 15px;
                font-size: 0.9em;
                background: rgba(0, 212, 170, 0.1);
                border: 1px solid rgba(0, 212, 170, 0.3);
            }

            .topology-btn[aria-pressed="true"] {
                background: linear-gradient(135deg, #00d4aa, #0099ff);
                color: #0a0e27;
            }

            @keyframes pulse {
                0% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
                100% {
                    transform: scale(1);
                }
            }

            .info-text {
                text-align: center;
                color: rgba(255, 255, 255, 0.6);
                margin-top: 10px;
                font-size: 0.9em;
            }

            .sr-only {
                position: absolute;
                left: -10000px;
                width: 1px;
                height: 1px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Resonant Bodies</h1>

            <div class="main-grid">
                <div class="panel">
                    <h3>Resonator Network</h3>
                    <div class="visualization">
                        <canvas
                            id="resonatorCanvas"
                            aria-label="Resonator network visualization"
                        ></canvas>
                    </div>
                    <div class="spectrum-display">
                        <canvas
                            id="spectrumCanvas"
                            aria-label="Frequency spectrum display"
                        ></canvas>
                    </div>
                </div>

                <div class="panel">
                    <h3>Controls</h3>
                    <div class="controls">
                        <div class="control-group">
                            <label for="coupling">Coupling Strength</label>
                            <div class="slider-container">
                                <input
                                    type="range"
                                    id="coupling"
                                    min="0"
                                    max="100"
                                    value="30"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="30"
                                />
                                <span class="value-display" id="couplingValue"
                                    >0.30</span
                                >
                            </div>
                        </div>

                        <div class="control-group">
                            <label for="damping">Global Damping</label>
                            <div class="slider-container">
                                <input
                                    type="range"
                                    id="damping"
                                    min="0"
                                    max="100"
                                    value="10"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="10"
                                />
                                <span class="value-display" id="dampingValue"
                                    >0.01</span
                                >
                            </div>
                        </div>

                        <div class="control-group">
                            <label for="stiffness">Material Stiffness</label>
                            <div class="slider-container">
                                <input
                                    type="range"
                                    id="stiffness"
                                    min="70"
                                    max="100"
                                    value="90"
                                    aria-valuemin="70"
                                    aria-valuemax="100"
                                    aria-valuenow="90"
                                />
                                <span class="value-display" id="stiffnessValue"
                                    >0.90</span
                                >
                            </div>
                        </div>

                        <div class="control-group">
                            <label for="tension">Tension Field</label>
                            <div class="slider-container">
                                <input
                                    type="range"
                                    id="tension"
                                    min="0"
                                    max="100"
                                    value="0"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                                    aria-valuenow="0"
                                />
                                <span class="value-display" id="tensionValue"
                                    >0.00</span
                                >
                            </div>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Network Topology</label>
                        <div
                            class="topology-selector"
                            role="group"
                            aria-label="Network topology selection"
                        >
                            <button
                                class="topology-btn"
                                data-topology="ring"
                                aria-pressed="true"
                            >
                                Ring
                            </button>
                            <button
                                class="topology-btn"
                                data-topology="grid"
                                aria-pressed="false"
                            >
                                Grid
                            </button>
                            <button
                                class="topology-btn"
                                data-topology="tree"
                                aria-pressed="false"
                            >
                                Tree
                            </button>
                            <button
                                class="topology-btn"
                                data-topology="mesh"
                                aria-pressed="false"
                            >
                                Mesh
                            </button>
                        </div>
                    </div>

                    <div class="control-group">
                        <label for="materialSpace"
                            >Material Space Navigation</label
                        >
                        <div
                            class="material-space"
                            id="materialSpace"
                            role="application"
                            aria-label="Click to navigate material space"
                        >
                            <div
                                id="materialIndicator"
                                aria-hidden="true"
                            ></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>Excitation</h3>
                <div class="button-grid">
                    <button id="startBtn" aria-label="Start audio engine">
                        Start Audio
                    </button>
                    <button
                        id="stopBtn"
                        aria-label="Stop audio engine"
                        disabled
                    >
                        Stop Audio
                    </button>
                    <button
                        id="randomExcite"
                        aria-label="Excite random resonator"
                        disabled
                    >
                        Random Strike
                    </button>
                    <button
                        id="bowAll"
                        aria-label="Bow all resonators"
                        disabled
                    >
                        Bow All
                    </button>
                </div>
                <div
                    class="excitation-buttons"
                    role="group"
                    aria-label="Individual resonator excitation"
                >
                    <button
                        class="excitation-btn"
                        data-resonator="0"
                        aria-label="Strike resonator 1"
                        disabled
                    >
                        Strike 1
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="1"
                        aria-label="Strike resonator 2"
                        disabled
                    >
                        Strike 2
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="2"
                        aria-label="Strike resonator 3"
                        disabled
                    >
                        Strike 3
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="3"
                        aria-label="Strike resonator 4"
                        disabled
                    >
                        Strike 4
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="4"
                        aria-label="Strike resonator 5"
                        disabled
                    >
                        Strike 5
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="5"
                        aria-label="Strike resonator 6"
                        disabled
                    >
                        Strike 6
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="6"
                        aria-label="Strike resonator 7"
                        disabled
                    >
                        Strike 7
                    </button>
                    <button
                        class="excitation-btn"
                        data-resonator="7"
                        aria-label="Strike resonator 8"
                        disabled
                    >
                        Strike 8
                    </button>
                </div>
            </div>

            <p class="info-text">
                Physical modeling synthesis using coupled waveguide resonators.
                Click material space to morph between imaginary materials.
            </p>
        </div>

        <script>
            "use strict";

            // Message type constants to avoid typos
            const MSG = Object.freeze({
                EXCITE: "excite",
                UPDATE_MATERIAL: "updateMaterial",
                SET_TOPOLOGY: "setTopology",
                SET_COUPLING: "setCoupling",
                SET_DAMPING: "setDamping",
                SET_STIFFNESS: "setStiffness",
                SET_TENSION: "setTension",
                RESET: "reset",
                CLOSE: "close",
                ENERGY: "energy",
                COUPLING_UPDATE: "couplingUpdate",
            });

            // WebAudio context and nodes
            let audioContext = null;
            let masterGain = null;
            let analyser = null;
            let isRunning = false;

            // Constants - now sample-rate aware
            const BASE_SAMPLE_RATE = 48000;
            const MAX_RESONATORS = 8;
            let MAX_DELAY_SAMPLES = 4800; // Will be recalculated based on sample rate
            let RESONATOR_ENERGY_SMOOTHING = 0.001;
            let COUPLING_ENERGY_SMOOTHING = 0.05;
            const DAMPING_SMOOTHING = 0.95;

            // Material constants
            const MATERIALS = {
                wood: { stiffness: 0.98, damping: 0.01 },
                metal: { stiffness: 0.995, damping: 0.005 },
                glass: { stiffness: 0.999, damping: 0.002 },
                membrane: { stiffness: 0.97, damping: 0.02 },
            };

            // Delay Line implementation
            class DelayLine {
                constructor(maxDelay) {
                    this.buffer = new Float32Array(maxDelay);
                    this.writeIdx = 0;
                    this.delaySamples = Math.floor(maxDelay / 2);
                    this.maxDelay = maxDelay;
                }

                read() {
                    const readIdx =
                        (this.writeIdx +
                            this.buffer.length -
                            this.delaySamples) %
                        this.buffer.length;
                    return this.buffer[readIdx];
                }

                write(sample) {
                    this.buffer[this.writeIdx] = sample;
                    this.writeIdx = (this.writeIdx + 1) % this.buffer.length;
                }

                setDelay(samples) {
                    this.delaySamples = Math.max(
                        1,
                        Math.min(samples, this.buffer.length - 1),
                    );
                }

                reset() {
                    this.buffer.fill(0);
                    this.writeIdx = 0;
                }
            }

            // One-pole filter for coupling
            class OnePoleFilter {
                constructor(cutoff) {
                    this.state = 0;
                    this.coefficient = Math.max(0, Math.min(cutoff, 0.99999));
                }

                process(input) {
                    this.state =
                        input * (1 - this.coefficient) +
                        this.state * this.coefficient;
                    return this.state;
                }

                setCutoff(cutoff) {
                    this.coefficient = Math.max(0, Math.min(cutoff, 0.99999));
                }

                reset() {
                    this.state = 0;
                }
            }

            // Waveguide Resonator
            class Resonator {
                constructor(id, position, sampleRate) {
                    this.id = id;
                    this.position = position;
                    this.sampleRate = sampleRate;

                    // Calculate max delay based on sample rate (100ms max)
                    const maxDelay = Math.ceil(0.1 * sampleRate);
                    this.forwardDelay = new DelayLine(maxDelay);
                    this.backwardDelay = new DelayLine(maxDelay);

                    this.baseDamping = 0.01;
                    this.stiffness = 0.98;
                    this.energy = 0;
                    this.excitationBuffer = 0;
                    this.excitationFilter = new OnePoleFilter(0.7);

                    // Set initial delay based on musical pitch
                    this.setDelayFromNote(48 + id * 2); // Start at C3, step by whole tones
                }

                process(couplingInput, dampingMod) {
                    const forward = this.forwardDelay.read();
                    const backward = this.backwardDelay.read();

                    const dampingFactor =
                        1 - Math.min(this.baseDamping * dampingMod, 0.5);

                    const smoothedExcitation = this.excitationFilter.process(
                        this.excitationBuffer,
                    );

                    const junction =
                        backward + smoothedExcitation + couplingInput;

                    const forwardWave = junction * dampingFactor;

                    const backwardWave =
                        -forward * dampingFactor * this.stiffness;

                    this.forwardDelay.write(Math.tanh(forwardWave));
                    this.backwardDelay.write(Math.tanh(backwardWave));

                    this.excitationBuffer = 0;

                    const output = forwardWave + backwardWave;

                    // Sample-rate aware energy smoothing
                    const energySmoothing =
                        RESONATOR_ENERGY_SMOOTHING *
                        (this.sampleRate / BASE_SAMPLE_RATE);
                    this.energy =
                        this.energy * (1 - energySmoothing) +
                        Math.abs(output) * energySmoothing;

                    return output;
                }

                excite(type, params) {
                    switch (type) {
                        case "strike":
                            const fundamental = 1 - params.position;
                            const harmonics = params.position * params.hardness;
                            this.excitationBuffer =
                                (fundamental + harmonics * 0.5) * 0.4;
                            break;
                        case "bow":
                            const stickSlip =
                                Math.sin(params.velocity * 10) *
                                params.pressure;
                            this.excitationBuffer =
                                stickSlip * (1 - params.position * 0.5);
                            break;
                        case "breath":
                            const noise =
                                (Math.random() * 2 - 1) * params.turbulence;
                            this.excitationBuffer =
                                params.pressure * 0.5 + noise;
                            break;
                    }
                }

                setMaterial(material) {
                    this.stiffness = material.stiffness;
                    this.baseDamping = material.damping;
                }

                // Improved delay calculation using wave physics
                setDelayFromPhysics(density, tension, length) {
                    // Wave speed = sqrt(tension / linear_density)
                    const linearDensity = density * length;
                    const waveSpeed = Math.sqrt(tension / linearDensity);
                    const frequency = (waveSpeed / (2 * length)) * 8;

                    const delaySamples = Math.floor(
                        this.sampleRate / frequency,
                    );
                    const clamped = Math.max(
                        2,
                        Math.min(delaySamples, this.forwardDelay.maxDelay - 1),
                    );
                    this.forwardDelay.setDelay(clamped);
                    this.backwardDelay.setDelay(clamped);
                }

                // Musical pitch-based delay setting
                setDelayFromNote(midiNote) {
                    const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
                    const delaySamples = Math.floor(
                        this.sampleRate / frequency,
                    );
                    const clamped = Math.max(
                        2,
                        Math.min(delaySamples, this.forwardDelay.maxDelay - 1),
                    );
                    this.forwardDelay.setDelay(clamped);
                    this.backwardDelay.setDelay(clamped);
                }

                reset() {
                    this.energy = 0;
                    this.excitationBuffer = 0;
                    this.excitationFilter.reset();
                    this.forwardDelay.reset();
                    this.backwardDelay.reset();
                }
            }

            // Coupling Network
            class CouplingNetwork {
                constructor() {
                    this.connections = [];
                    this.topology = "ring";
                    this.couplingStrength = 0.3;
                    this.filters = [];

                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        this.connections[i] = [];
                        this.filters[i] = [];
                    }

                    this.rebuildTopology();
                }

                rebuildTopology() {
                    // Clear connections and filters
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        this.connections[i] = [];
                        // Reset existing filters instead of creating new ones
                        for (let j = 0; j < MAX_RESONATORS; j++) {
                            if (this.filters[i][j]) {
                                this.filters[i][j].reset();
                            }
                        }
                    }

                    switch (this.topology) {
                        case "ring":
                            this.buildRing();
                            break;
                        case "grid":
                            this.buildGrid(4, 2);
                            break;
                        case "tree":
                            this.buildTree(3);
                            break;
                        case "mesh":
                            this.buildMesh();
                            break;
                    }

                    return this.couplingStrength; // Return for UI update
                }

                buildRing() {
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        const next = (i + 1) % MAX_RESONATORS;
                        const prev = (i + MAX_RESONATORS - 1) % MAX_RESONATORS;
                        this.addConnection(i, next, 0.5);
                        this.addConnection(i, prev, 0.5);
                    }
                }

                buildGrid(width, height) {
                    for (let y = 0; y < height; y++) {
                        for (let x = 0; x < width; x++) {
                            const idx = y * width + x;
                            if (idx >= MAX_RESONATORS) break;

                            if (x > 0) this.addConnection(idx, idx - 1, 0.4);
                            if (x < width - 1 && idx + 1 < MAX_RESONATORS) {
                                this.addConnection(idx, idx + 1, 0.4);
                            }
                            if (y > 0 && idx >= width) {
                                this.addConnection(idx, idx - width, 0.4);
                            }
                            if (
                                y < height - 1 &&
                                idx + width < MAX_RESONATORS
                            ) {
                                this.addConnection(idx, idx + width, 0.4);
                            }
                        }
                    }
                }

                buildTree(branches) {
                    for (let i = 1; i <= branches && i < MAX_RESONATORS; i++) {
                        this.addConnection(0, i, 0.6);
                    }

                    let current = branches + 1;
                    for (let parent = 1; parent <= branches; parent++) {
                        for (let j = 0; j < 2; j++) {
                            if (current >= MAX_RESONATORS) break;
                            this.addConnection(parent, current, 0.4);
                            current++;
                        }
                    }
                }

                buildMesh() {
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        for (let j = 0; j < MAX_RESONATORS; j++) {
                            if (i !== j) {
                                const distance = 1 / (Math.abs(i - j) + 1);
                                this.addConnection(i, j, distance * 0.2);
                            }
                        }
                    }
                }

                addConnection(from, to, strength) {
                    if (from < MAX_RESONATORS && to < MAX_RESONATORS) {
                        this.connections[from].push({ to, strength });
                        if (!this.filters[from]) this.filters[from] = [];
                        if (!this.filters[from][to]) {
                            this.filters[from][to] = new OnePoleFilter(0.8);
                        }
                    }
                }

                calculateCoupling(resonatorOutputs) {
                    const coupling = new Float32Array(MAX_RESONATORS);

                    for (let from = 0; from < MAX_RESONATORS; from++) {
                        for (const conn of this.connections[from]) {
                            const filter =
                                this.filters[from] &&
                                this.filters[from][conn.to];
                            if (filter) {
                                const filtered = filter.process(
                                    resonatorOutputs[from],
                                );
                                const signal =
                                    filtered *
                                    conn.strength *
                                    this.couplingStrength;
                                coupling[conn.to] += signal;
                            }
                        }
                    }

                    return coupling;
                }

                reset() {
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        if (this.filters[i]) {
                            for (let j = 0; j < MAX_RESONATORS; j++) {
                                if (this.filters[i][j]) {
                                    this.filters[i][j].reset();
                                }
                            }
                        }
                    }
                }
            }

            // Spatial Processor
            class SpatialProcessor {
                constructor(sampleRate) {
                    this.sampleRate = sampleRate;
                    this.listenerPosition = [0, 0, 1];
                    this.panCoefficients = new Float32Array(MAX_RESONATORS * 2);
                    this.updatePanning();
                }

                updatePanning() {
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        const angle = (i / MAX_RESONATORS) * Math.PI * 2;
                        const pan = (angle / Math.PI + 1) * 0.5;
                        this.panCoefficients[i * 2] = Math.sqrt(1 - pan);
                        this.panCoefficients[i * 2 + 1] = Math.sqrt(pan);
                    }
                }

                process(resonatorOutputs) {
                    let left = 0,
                        right = 0;

                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        left +=
                            resonatorOutputs[i] * this.panCoefficients[i * 2];
                        right +=
                            resonatorOutputs[i] *
                            this.panCoefficients[i * 2 + 1];
                    }

                    return [left, right];
                }
            }

            // Main Synthesizer Engine
            class ResonantBodiesSynth {
                constructor(sampleRate) {
                    this.sampleRate = sampleRate;

                    // Update sample-rate dependent constants
                    MAX_DELAY_SAMPLES = Math.ceil(0.1 * sampleRate); // 100ms max delay
                    RESONATOR_ENERGY_SMOOTHING =
                        0.001 * (BASE_SAMPLE_RATE / sampleRate);
                    COUPLING_ENERGY_SMOOTHING =
                        0.05 * (BASE_SAMPLE_RATE / sampleRate);

                    this.resonators = [];
                    this.couplingNetwork = new CouplingNetwork();
                    this.spatialProcessor = new SpatialProcessor(sampleRate);
                    this.materialPosition = [0.5, 0.5, 0.5];
                    this.tensionField = 0;

                    // Initialize resonators
                    for (let i = 0; i < MAX_RESONATORS; i++) {
                        const angle = (i / MAX_RESONATORS) * Math.PI * 2;
                        const position = [
                            Math.cos(angle) * 2,
                            0,
                            Math.sin(angle) * 2,
                        ];
                        this.resonators.push(
                            new Resonator(i, position, sampleRate),
                        );
                    }

                    this.resonatorOutputs = new Float32Array(MAX_RESONATORS);
                    this.previousOutputs = new Float32Array(MAX_RESONATORS);
                }

                process(outputBuffer, bufferSize) {
                    const dampingMod = 1 + this.tensionField * 0.01;

                    for (let sample = 0; sample < bufferSize; sample++) {
                        // Calculate coupling from previous outputs
                        const couplingInputs =
                            this.couplingNetwork.calculateCoupling(
                                this.previousOutputs,
                            );

                        // Process each resonator
                        for (let i = 0; i < MAX_RESONATORS; i++) {
                            this.resonatorOutputs[i] = this.resonators[
                                i
                            ].process(couplingInputs[i], dampingMod);
                        }

                        // Save for next iteration
                        this.previousOutputs.set(this.resonatorOutputs);

                        // Spatial processing
                        const [left, right] = this.spatialProcessor.process(
                            this.resonatorOutputs,
                        );

                        outputBuffer[sample * 2] = Math.max(
                            -1,
                            Math.min(1, left * 0.5),
                        );
                        outputBuffer[sample * 2 + 1] = Math.max(
                            -1,
                            Math.min(1, right * 0.5),
                        );
                    }
                }

                exciteResonator(index, type, params) {
                    if (index < this.resonators.length) {
                        this.resonators[index].excite(type, params);
                    }
                }

                updateMaterialPosition(x, y, z) {
                    this.materialPosition = [x, y, z];

                    const material = {
                        stiffness: 0.9 + x * 0.099,
                        damping: y * 0.1,
                    };

                    for (let i = 0; i < this.resonators.length; i++) {
                        const resonator = this.resonators[i];
                        resonator.setMaterial(material);

                        // Use physics-based delay calculation
                        const tension = 50 + (1 - x) * 150; // Tension varies with density
                        const length = 0.5 + i * 0.1; // Each resonator has different length
                        resonator.setDelayFromPhysics(x, tension, length);
                    }

                    this.couplingNetwork.couplingStrength = z;
                }

                setTopology(topology) {
                    this.couplingNetwork.topology = topology;
                    return this.couplingNetwork.rebuildTopology();
                }

                reset() {
                    for (const resonator of this.resonators) {
                        resonator.reset();
                    }
                    this.couplingNetwork.reset();
                    this.previousOutputs.fill(0);
                    this.resonatorOutputs.fill(0);
                }

                close() {
                    this.reset();
                    // Additional cleanup if needed
                }
            }

            // Bridge for unified message handling
            class SynthBridge {
                constructor(workletNode, synthFallback) {
                    this.workletNode = workletNode;
                    this.synthFallback = synthFallback;
                    this.messageHandlers = new Map();
                }

                post(type, data) {
                    if (this.workletNode && this.workletNode.port) {
                        this.workletNode.port.postMessage({ type, data });
                    } else if (this.synthFallback) {
                        this.handleFallback(type, data);
                    }
                }

                handleFallback(type, data) {
                    switch (type) {
                        case MSG.EXCITE:
                            this.synthFallback.exciteResonator(
                                data.index,
                                data.excitationType,
                                data.params,
                            );
                            break;
                        case MSG.UPDATE_MATERIAL:
                            this.synthFallback.updateMaterialPosition(
                                data.x,
                                data.y,
                                data.z,
                            );
                            break;
                        case MSG.SET_TOPOLOGY:
                            const newStrength = this.synthFallback.setTopology(
                                data.topology,
                            );
                            // Update UI
                            document.getElementById(
                                "couplingValue",
                            ).textContent = newStrength.toFixed(2);
                            document.getElementById("coupling").value =
                                newStrength * 100;
                            break;
                        case MSG.SET_COUPLING:
                            this.synthFallback.couplingNetwork.couplingStrength =
                                data.value;
                            break;
                        case MSG.SET_DAMPING:
                            for (let res of this.synthFallback.resonators) {
                                res.baseDamping = data.value;
                            }
                            break;
                        case MSG.SET_STIFFNESS:
                            for (let res of this.synthFallback.resonators) {
                                res.stiffness = data.value;
                            }
                            break;
                        case MSG.SET_TENSION:
                            this.synthFallback.tensionField = data.value;
                            break;
                        case MSG.RESET:
                            this.synthFallback.reset();
                            break;
                        case MSG.CLOSE:
                            this.synthFallback.close();
                            break;
                    }
                }

                onMessage(handler) {
                    if (this.workletNode && this.workletNode.port) {
                        this.workletNode.port.onmessage = handler;
                    }
                }
            }

            // Audio processor worklet code (compact version of classes)
            const processorCode = `
                const MSG = ${JSON.stringify(MSG)};
                const BASE_SAMPLE_RATE = ${BASE_SAMPLE_RATE};
                const MAX_RESONATORS = ${MAX_RESONATORS};

                let   MAX_DELAY_SAMPLES           = 4800;
                let   RESONATOR_ENERGY_SMOOTHING  = 0.001;
                let   COUPLING_ENERGY_SMOOTHING   = 0.05;
                const DAMPING_SMOOTHING           = 0.95;

                ${DelayLine.toString()}
                ${OnePoleFilter.toString()}
                ${Resonator.toString()}
                ${CouplingNetwork.toString()}
                ${SpatialProcessor.toString()}
                ${ResonantBodiesSynth.toString()}

                class ResonantBodiesProcessor extends AudioWorkletProcessor {
                    constructor() {
                        super();
                        this.synth = new ResonantBodiesSynth(sampleRate);
                        this.sampleCount = 0;
                        this.samplesUntilReport = 4096;

                        this.port.onmessage = (e) => {
                            const { type, data } = e.data;

                            switch(type) {
                                case MSG.EXCITE:
                                    this.synth.exciteResonator(data.index, data.excitationType, data.params);
                                    break;
                                case MSG.UPDATE_MATERIAL:
                                    this.synth.updateMaterialPosition(data.x, data.y, data.z);
                                    break;
                                case MSG.SET_TOPOLOGY:
                                    const newStrength = this.synth.setTopology(data.topology);
                                    this.port.postMessage({ type: MSG.COUPLING_UPDATE, data: newStrength });
                                    break;
                                case MSG.SET_COUPLING:
                                    this.synth.couplingNetwork.couplingStrength = data.value;
                                    break;
                                case MSG.SET_DAMPING:
                                    for (let res of this.synth.resonators) {
                                        res.baseDamping = data.value;
                                    }
                                    break;
                                case MSG.SET_STIFFNESS:
                                    for (let res of this.synth.resonators) {
                                        res.stiffness = data.value;
                                    }
                                    break;
                                case MSG.SET_TENSION:
                                    this.synth.tensionField = data.value;
                                    break;
                                case MSG.RESET:
                                    this.synth.reset();
                                    break;
                                case MSG.CLOSE:
                                    this.synth.close();
                                    break;
                            }
                        };
                    }

                    process(inputs, outputs, parameters) {
                        const output = outputs[0];
                        let bufferSize = 0;

                        if (output.length > 0) {
                            bufferSize = output[0].length;
                            const interleavedBuffer = new Float32Array(bufferSize * 2);

                            this.synth.process(interleavedBuffer, bufferSize);

                            // De-interleave
                            for (let i = 0; i < bufferSize; i++) {
                                output[0][i] = interleavedBuffer[i * 2];
                                output[1][i] = interleavedBuffer[i * 2 + 1];
                            }

                            // Send energy data back to main thread (throttled)
                            if (Math.random() < 0.1) {
                                const energies = this.synth.resonators.map(r => r.energy);
                                this.port.postMessage({ type: MSG.ENERGY, data: energies });
                            }
                        }

                        if (bufferSize > 0) {
                            // --- Start of New Data Reporting Code ---
                            this.sampleCount += bufferSize;

                            if (this.sampleCount >= this.samplesUntilReport) {
                                this.sampleCount -= this.samplesUntilReport;

                                let peakAmplitude = 0;
                                for (let i = 0; i < bufferSize; i++) {
                                    const absSample = Math.abs(output[0][i]);
                                    if (absSample > peakAmplitude) {
                                        peakAmplitude = absSample;
                                    }
                                }

                                const resonatorData = this.synth.resonators.map(r => {
                                    return {
                                        id: r.id,
                                        energy: r.energy,
                                        frequency: sampleRate / r.forwardDelay.delaySamples
                                    };
                                });

                                this.port.postMessage({
                                    type: 'analysisData',
                                    data: {
                                        peakAmplitude: peakAmplitude,
                                        resonators: resonatorData
                                    }
                                });
                            }
                            // --- End of New Data Reporting Code ---
                        }

                        return true;
                    }
                }

                registerProcessor('resonant-bodies-processor', ResonantBodiesProcessor);
            `;

            let processorNode = null;
            let synthBridge = null;

            // Initialize audio
            async function initAudio() {
                if (audioContext) return;

                audioContext = new (window.AudioContext ||
                    window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.4; // Ensure gain is not muted

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 1024;

                try {
                    // Try to use AudioWorklet
                    const blob = new Blob([processorCode], {
                        type: "application/javascript",
                    });
                    const workletUrl = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(workletUrl);

                    processorNode = new AudioWorkletNode(
                        audioContext,
                        "resonant-bodies-processor",
                        {
                            outputChannelCount: [2], // stereo
                            numberOfInputs: 0,
                            numberOfOutputs: 1,
                        },
                    );
                    processorNode.connect(masterGain);

                    synthBridge = new SynthBridge(processorNode, null);

                    // Handle messages from processor
                    synthBridge.onMessage((e) => {
                        if (e.data.type === MSG.ENERGY) {
                            updateVisualization(e.data.data);
                        } else if (e.data.type === MSG.COUPLING_UPDATE) {
                            document.getElementById(
                                "couplingValue",
                            ).textContent = e.data.data.toFixed(2);
                            document.getElementById("coupling").value =
                                e.data.data * 100;
                        } else if (e.data.type === "analysisData") {
                            const data = e.data.data;

                            console.log(
                                `Peak Amplitude: ${data.peakAmplitude.toFixed(4)}`,
                            );
                            console.table(data.resonators);
                        }
                    });
                } catch (error) {
                    console.log(
                        "AudioWorklet not supported, falling back to ScriptProcessor",
                    );

                    // Fallback to ScriptProcessor
                    const synth = new ResonantBodiesSynth(
                        audioContext.sampleRate,
                    );
                    processorNode = audioContext.createScriptProcessor(
                        2048,
                        0,
                        2,
                    );

                    processorNode.onaudioprocess = (e) => {
                        const output = e.outputBuffer;
                        const bufferSize = output.length;
                        const interleavedBuffer = new Float32Array(
                            bufferSize * 2,
                        );

                        synth.process(interleavedBuffer, bufferSize);

                        for (let i = 0; i < bufferSize; i++) {
                            output.getChannelData(0)[i] =
                                interleavedBuffer[i * 2];
                            output.getChannelData(1)[i] =
                                interleavedBuffer[i * 2 + 1];
                        }

                        // Update visualization (throttled)
                        if (Math.random() < 0.1) {
                            const energies = synth.resonators.map(
                                (r) => r.energy,
                            );
                            updateVisualization(energies);
                        }
                    };

                    processorNode.connect(masterGain);
                    synthBridge = new SynthBridge(null, synth);
                }

                masterGain.connect(analyser);
                analyser.connect(audioContext.destination);
            }

            // Stop audio properly
            async function stopAudio() {
                if (!audioContext) return;

                // Send reset and close messages
                synthBridge.post(MSG.RESET, {});
                synthBridge.post(MSG.CLOSE, {});

                // Disconnect nodes
                if (processorNode) {
                    processorNode.disconnect();
                }
                if (masterGain) {
                    masterGain.disconnect();
                }
                if (analyser) {
                    analyser.disconnect();
                }

                await audioContext.suspend();

                // Clear visualization
                resonatorEnergies.fill(0);
            }

            // Visualization with high-DPI support
            const resonatorCanvas = document.getElementById("resonatorCanvas");
            const resonatorCtx = resonatorCanvas.getContext("2d");
            const spectrumCanvas = document.getElementById("spectrumCanvas");
            const spectrumCtx = spectrumCanvas.getContext("2d");

            function resizeCanvases() {
                const dpr = window.devicePixelRatio || 1;

                // Resonator canvas
                const resonatorRect = resonatorCanvas.getBoundingClientRect();
                resonatorCanvas.width = resonatorRect.width * dpr;
                resonatorCanvas.height = resonatorRect.height * dpr;
                resonatorCtx.scale(dpr, dpr);

                // Spectrum canvas
                const spectrumRect = spectrumCanvas.getBoundingClientRect();
                spectrumCanvas.width = spectrumRect.width * dpr;
                spectrumCanvas.height = spectrumRect.height * dpr;
                spectrumCtx.scale(dpr, dpr);
            }

            window.addEventListener("resize", resizeCanvases);
            resizeCanvases();

            let resonatorEnergies = new Float32Array(MAX_RESONATORS);

            function updateVisualization(energies) {
                if (energies) {
                    resonatorEnergies = new Float32Array(energies);
                }
            }

            function drawResonatorNetwork() {
                const ctx = resonatorCtx;
                const rect = resonatorCanvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;

                ctx.clearRect(0, 0, width, height);

                // Draw connections
                ctx.strokeStyle = "rgba(0, 212, 170, 0.2)";
                ctx.lineWidth = 1;

                for (let i = 0; i < MAX_RESONATORS; i++) {
                    const angle1 =
                        (i / MAX_RESONATORS) * Math.PI * 2 - Math.PI / 2;
                    const x1 = centerX + Math.cos(angle1) * radius;
                    const y1 = centerY + Math.sin(angle1) * radius;

                    // Draw connections based on topology
                    const next = (i + 1) % MAX_RESONATORS;
                    const angle2 =
                        (next / MAX_RESONATORS) * Math.PI * 2 - Math.PI / 2;
                    const x2 = centerX + Math.cos(angle2) * radius;
                    const y2 = centerY + Math.sin(angle2) * radius;

                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }

                // Draw resonator nodes
                for (let i = 0; i < MAX_RESONATORS; i++) {
                    const angle =
                        (i / MAX_RESONATORS) * Math.PI * 2 - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;

                    const energy = resonatorEnergies[i] || 0;
                    const size = 10 + energy * 30;

                    // Glow effect
                    const gradient = ctx.createRadialGradient(
                        x,
                        y,
                        0,
                        x,
                        y,
                        size,
                    );
                    gradient.addColorStop(
                        0,
                        `rgba(255, 255, 255, ${0.8 + energy * 0.2})`,
                    );
                    gradient.addColorStop(
                        0.5,
                        `rgba(0, 212, 170, ${0.5 + energy * 0.5})`,
                    );
                    gradient.addColorStop(1, "rgba(0, 153, 255, 0)");

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Throttled spectrum drawing (30 fps)
            let lastSpectrumDraw = 0;
            function drawSpectrum(now) {
                if (!analyser || now - lastSpectrumDraw < 33) return; // 30 fps throttle
                lastSpectrumDraw = now;

                const ctx = spectrumCtx;
                const rect = spectrumCanvas.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;

                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);

                ctx.clearRect(0, 0, width, height);

                const barWidth = (width / bufferLength) * 2.5;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * height;

                    const gradient = ctx.createLinearGradient(
                        0,
                        height - barHeight,
                        0,
                        height,
                    );
                    gradient.addColorStop(0, "rgba(0, 212, 170, 0.8)");
                    gradient.addColorStop(1, "rgba(0, 153, 255, 0.3)");

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);

                    x += barWidth + 1;
                }
            }

            function animate(now) {
                drawResonatorNetwork();
                drawSpectrum(now);
                requestAnimationFrame(animate);
            }

            animate(0);

            // UI Event Handlers
            const startBtn = document.getElementById("startBtn");
            const stopBtn = document.getElementById("stopBtn");
            const excitationButtons = document.querySelectorAll(
                ".excitation-btn, #randomExcite, #bowAll",
            );

            startBtn.addEventListener("click", async () => {
                await initAudio();
                if (audioContext.state === "suspended") {
                    await audioContext.resume();
                }
                isRunning = true;

                // Update button states
                startBtn.disabled = true;
                stopBtn.disabled = false;
                excitationButtons.forEach((btn) => (btn.disabled = false));
            });

            stopBtn.addEventListener("click", async () => {
                if (audioContext) {
                    await stopAudio();
                    isRunning = false;

                    // Update button states
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    excitationButtons.forEach((btn) => (btn.disabled = true));
                }
            });

            document
                .getElementById("randomExcite")
                .addEventListener("click", () => {
                    const index = Math.floor(Math.random() * MAX_RESONATORS);
                    synthBridge.post(MSG.EXCITE, {
                        index,
                        excitationType: "strike",
                        params: {
                            position: Math.random(),
                            hardness: 0.5 + Math.random() * 0.5,
                        },
                    });
                });

            document.getElementById("bowAll").addEventListener("click", () => {
                for (let i = 0; i < MAX_RESONATORS; i++) {
                    setTimeout(() => {
                        synthBridge.post(MSG.EXCITE, {
                            index: i,
                            excitationType: "bow",
                            params: {
                                position: 0.3,
                                pressure: 0.7,
                                velocity: 2 + Math.random() * 2,
                            },
                        });
                    }, i * 50);
                }
            });

            // Excitation buttons
            document.querySelectorAll(".excitation-btn").forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    const index = parseInt(e.target.dataset.resonator);
                    synthBridge.post(MSG.EXCITE, {
                        index,
                        excitationType: "strike",
                        params: {
                            position: 0.5,
                            hardness: 0.8,
                        },
                    });
                });
            });

            // Sliders with proper value sync
            document
                .getElementById("coupling")
                .addEventListener("input", (e) => {
                    const value = e.target.value / 100;
                    document.getElementById("couplingValue").textContent =
                        value.toFixed(2);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                    synthBridge.post(MSG.SET_COUPLING, { value });
                });

            document
                .getElementById("damping")
                .addEventListener("input", (e) => {
                    const value = e.target.value / 1000; // Fixed: now correctly divides by 1000
                    document.getElementById("dampingValue").textContent =
                        value.toFixed(3);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                    synthBridge.post(MSG.SET_DAMPING, { value });
                });

            document
                .getElementById("stiffness")
                .addEventListener("input", (e) => {
                    const value = e.target.value / 100;
                    document.getElementById("stiffnessValue").textContent =
                        value.toFixed(2);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                    synthBridge.post(MSG.SET_STIFFNESS, { value });
                });

            document
                .getElementById("tension")
                .addEventListener("input", (e) => {
                    const value = e.target.value / 100;
                    document.getElementById("tensionValue").textContent =
                        value.toFixed(2);
                    e.target.setAttribute("aria-valuenow", e.target.value);
                    synthBridge.post(MSG.SET_TENSION, { value });
                });

            // Topology buttons with ARIA
            document.querySelectorAll(".topology-btn").forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    document.querySelectorAll(".topology-btn").forEach((b) => {
                        b.setAttribute("aria-pressed", "false");
                    });
                    e.target.setAttribute("aria-pressed", "true");
                    synthBridge.post(MSG.SET_TOPOLOGY, {
                        topology: e.target.dataset.topology,
                    });
                });
            });

            // Material space navigation
            const materialSpace = document.getElementById("materialSpace");
            const materialIndicator =
                document.getElementById("materialIndicator");

            materialSpace.addEventListener("click", (e) => {
                const rect = materialSpace.getBoundingClientRect();
                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;

                materialIndicator.style.left = `${x * 100}%`;
                materialIndicator.style.top = `${y * 100}%`;

                synthBridge.post(MSG.UPDATE_MATERIAL, { x, y, z: 0.5 });
            });

            // Initialize material indicator position
            materialIndicator.style.left = "50%";
            materialIndicator.style.top = "50%";

            // Keyboard support
            document.addEventListener("keydown", (e) => {
                if (!isRunning) return;

                // Number keys 1-8 trigger resonators
                if (e.key >= "1" && e.key <= "8") {
                    const index = parseInt(e.key) - 1;
                    if (index < MAX_RESONATORS) {
                        synthBridge.post(MSG.EXCITE, {
                            index,
                            excitationType: "strike",
                            params: {
                                position: 0.5,
                                hardness: 0.8,
                            },
                        });
                    }
                }

                // Space bar for random excitation
                if (e.key === " ") {
                    e.preventDefault();
                    document.getElementById("randomExcite").click();
                }
            });
        </script>
    </body>
</html>
